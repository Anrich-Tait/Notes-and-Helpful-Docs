% Created 2023-03-03 Fri 07:05
% Intended LaTeX compiler: pdflatex
\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Anrich Tait}
\date{\today}
\title{ORG MODE TEMPLATE}
\hypersetup{
 pdfauthor={Anrich Tait},
 pdftitle={ORG MODE TEMPLATE},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.2 (Org mode 9.5.5)}, 
 pdflang={English}}
\begin{document}

\section{Template stuff:}
\label{sec:org82ddd03}
%\documentclass[a4paper, 11pt]{book} % A4 paper size and default 11pt font size

\newcommand*{\plogo}{\fbox{$\mathcal{PL}$}} % Generic dummy publisher logo

%\usepackage[utf8]{inputenc} % Required for inputting international characters
%\usepackage[T1]{fontenc} % Output font encoding for international characters
%\usepackage{stix} % Use the STIX fonts



%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begin{titlepage} % Suppresses displaying the page number on the title page and the subsequent page counts as page 1
	
	\raggedleft % Right align the title page
	
	\rule{1pt}{\textheight} % Vertical line
	\hspace{0.05\textwidth} % Whitespace between the vertical line and title page text
	\parbox[b]{0.75\textwidth}{ % Paragraph box for holding the title page text, adjust the width to move the title page left or right on the page
		
		{\Huge\bfseries C Programming \\[0.5\baselineskip] Language}\\[2\baselineskip] % Title
		{\large\textit{Compendium }}\\[4\baselineskip] % Subtitle or further description
		{\Large\textsc{anrich tait}} % Author name, lower case for consistent small caps
		
		\vspace{0.5\textheight} % Whitespace between the title block and the publisher
		
		{\noindent Written 2023}\\[\baselineskip] % Publisher and logo
	}


\end{titlepage}
%----------------------------------------------------------------------------------------

\tableofcontents
\newpage

\section{{\bfseries\sffamily TODO} Introduction}
\label{sec:orga103549}


\subsection{Example Template:}
\label{sec:org7814c2b}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  printf("This is a template!");
}
\end{verbatim}
Output: 
\begin{verbatim}
This is a template!
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\clearpage
\section{Output (printf):}
\label{sec:org4546fd9}
To output values or print text in c, you can use the \textbf{printf()} function.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  printf("hello, world");
}
\end{verbatim}
\textbf{Output:}
\begin{verbatim}
hello, world
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

There is no limit to the amount of one function you can put in a program. In the
case of the printf function keep in mind that using multiple \textbf{printf()}
functions will not ouput a new line. See below:

\noindent\rule{\textwidth}{0.5pt}

\begin{verbatim}
#include <stdio.h>

int main(){
  printf("hello, world");
  printf("I am learning C!");
}
\end{verbatim}
\textbf{Output:}
\begin{verbatim}
hello, worldI am learning C!
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\clearpage
\section{Basic escape sequences:}
\label{sec:orgdcfeb34}
Escape sequences are used to do various things, like adding new lines and adding
characters that the compiler would normally conflict with. See below:
\begin{center}
\begin{tabular}{ll}
\hline
ESCAPE SEQUENCE & DESCRIPTION\\
\hline
\t & Creates a horizontal tab\\
$\backslash$\ & Inserts a backslash character ($\backslash$)\\
$\backslash$" & Inserts a double quote character\\
\hline
\end{tabular}
\end{center}

\subsection{Insert a new line:}
\label{sec:org50c3aa3}
To insert a new line we need to use the \textbf{\n} character. 

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  printf("hello, world \n");
  printf("I am learning C! \n");

  // You can also use \n characters to create blank lines:
  printf("Do you see? \n\n");
  printf("YES/NO");
}
\end{verbatim}
Output:
\begin{verbatim}
hello, world 
I am learning C! 
Do you see? 

YES/NO
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\clearpage
\section{Comments:}
\label{sec:org0217a54}
Comments are used to explain code and make it more readable. It is also a good
way to make sure the compiler doesn't execute a block of code when you are
testing changes.
Comments can be single-lined or multi-lined.
\subsection{Single-lined comments:}
\label{sec:orgd24f437}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  printf("This is an example of a single line comment.");
//  printf("I hope this doesn't get executed.");
}
\end{verbatim}
\textbf{Output:}
\begin{verbatim}
This is an example of a single line comment.
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Multi-lined comments:}
\label{sec:org24591a0}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  printf("This is an example of a multi-lined comment.");
  /*
    printf("This won't be executed.") <-- No syntax errors in comments
    printf("Found a bug? Maybe just comment the code out.");
    */
}
\end{verbatim}
\textbf{Output:}
\begin{verbatim}
This is an example of a multi-lined comment.
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\clearpage
\section{Data types:}
\label{sec:orgdb286d2}
Data types in c refer to an extensive system used for declaring variables or
functions of different types.
The type of a variable determines how much space it occupies in storage and how
the bit pattern stored is interpreted.

The different C data types are classified as follows:
\begin{center}
\begin{tabular}{l|l}
\hline
TYPE & DESCRIPTION\\
\hline
Basic types & Arithmetic types that are further classified into:\\
 & a: Integer types\\
 & b: Floating-point numbers\\
\hline
Enumerated types & Arithmetic types that are used to define variables that can\\
 & only assign certain discrete integer values throughout the\\
 & program\\
\hline
Void type & Indicates that no value is available\\
\hline
Derived types & They include:\\
 & a: Pointer types\\
 & b: Array types\\
 & c: Structure types\\
 & d: Union types\\
 & e: Function types\\
\hline
\end{tabular}
\end{center}

The array types and structur etypes are reffered collectively as the aggregate
types. The type of a function specifies the type of the functions return
value. See the basic types in the following sections.

\subsection{Basic Data types (quick reference):}
\label{sec:orgd5c8019}
In the following sub-sections detailed descriptions and uses for each data type
are given. The table below is a quick reference for all the basic types and
their format specifiers:
\begin{center}
\begin{tabular}{l|l|l}
\hline
DATA TYPE & DESCRIPTION & FORMAT SPECIFIER\\
\hline
int & Stores whole numbers without decimals & \%d or \%i\\
\hline
 & Stores fractional numbers, containing one or & \\
float & more decimals. Sufficient for storing 6-7 & \%f\\
 & decimal digits. & \\
\hline
 & Stores fractional numbers, containing one or & \\
double & more decimals. Sufficient for storing 15 & \%lf\\
 & decimal digits. & \\
\hline
char & Stores a single character/letter/number or & \%c\\
 & ASCII value & \\
\hline
string & Stores two ore more characters & \%s\\
\hline
\end{tabular}
\end{center}
\subsection{Set decimal precision:}
\label{sec:orgba0b31b}
If you print a floating point number it will output many digits after the
decimal point. If you want to remove the extra decimals (set decimal
precision), you can use a dot (.) followed by a number that specifies how many
digits that should be shown after the decimal point:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  float myFloat = 3.5; 
  printf("%f\n", myFloat); //Will show 6 digits after decimal point.
  printf("%.1f\n", myFloat); // Only show 1 digit.
  printf("%.2f\n", myFloat); //Only show 2 digits.
  printf("%.4f", myFloat); //Only show 4 digits.
}
\end{verbatim}
Output:
\begin{verbatim}
3.500000
3.5
3.50
3.5000
\end{verbatim}


\noindent\rule{\textwidth}{0.5pt}

\subsection{Type conversion:}
\label{sec:org2d09c87}
Sometimes you have to convert the value of one data type to another. This is
known as type conversion:
For example if you divide two integers, 5 and 2. You would expect the result to
be 2.5 but since they are integers (and not floating-point) numbers the output
will be 2.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x = 5;
  int y = 2;
  int sum = 5 / 2;

  printf("%d", sum); // outputs 2
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
2
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

To get the right result, you need to know how type conversion works.

There are two types of conversion in C:
\begin{itemize}
\item Implicit Conversion (automatically)
\item Explicity Conversion (manually)
\end{itemize}

\subsubsection{Implicit Conversion:}
\label{sec:org0cfaf6c}
Implicit conversion is done automatically by the compiler when you assign a
value of one type to another.
For example if you assign int to a float type:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  // Automatic conversion: int to float
  float myFloat = 9;

  printf("%f", myFloat);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
9.0
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

As you can see the compiler automatically converts the int value 9 to a float
value 9.0.
This may be risky due to you losing control over specific values in certain
situations.
Especially when it is the other way around - the following example automatically
converts the float value 9.99 to an int value of 9:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  // automatic conversion: float to int
  int myInt = 9.99;
  printf("%d", myInt);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
9
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
See how the output is just 9. For some programs that extra .99 may be necessary
(most likley it is).

As another example, if you divide two integers: 5 by 2, you know the sum result
should be 2.5. Like previously mentioned if you store the sum as an integer, the
result will only display the number 2, therefore it would be better to store the
sum as a float or a double (right?).

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  float sum = 5 / 2;
  printf("%f", sum);
}
\end{verbatim}
Output:
\begin{verbatim}
2.0
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
As you can see the result is 2.0 not 2.5. This is because 5 and 2 are still
integers in the division. In this case you will need to manually convert the
integer values to floating-point values.
For the we use Explicit Conversion.

\subsubsection{Explicit Conversion:}
\label{sec:org24a5b9a}
Explicit conversion is done manually by placing the type in parentheses () in
front of the value.

Considering our problem from the example above, we can now get the right result:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  //manual conversion: int to float
  float sum = (float) 5 / 2;
  printf("%f", sum); //2.5
}
\end{verbatim}
Output:
\begin{verbatim}
2.5
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
You can also place the type in front of the variable:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int num1 = 5;
  int num2 = 2;
  float sum = (float) num1 / num2;

  printf("%f", sum); //2.5
}
\end{verbatim}
Output:
\begin{verbatim}
2.5
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Integer Types:}
\label{sec:org1307964}
The following table provides the details of standard integer tyoes with their
storage size and value ranges:
\begin{center}
\begin{tabular}{l|l|l}
\hline
TYPE & STORAGE SIZE & VALUE RANGE\\
\hline
char & 1 byte & -128 to 127 or 0 to 225\\
\hline
unsigned char & 1 byte & 0 to 255\\
\hline
signed char & 1 byte & -128 to 127\\
\hline
int & 2 or 4 bytes & -32,768 to 32,768 or -2,147,483,648\\
 &  & to 2,147,483,647\\
\hline
unsigned it & 2 or 4 bytes & 0 to 65,535 or 0 to 4,294,967,295\\
\hline
short & 2 bytes & -32,768 to 32,767\\
\hline
unsigned short & 2 bytes & 0 to 65,535\\
\hline
long & 8 bytes or & -9223372036854775808 to 9223372036854775807\\
 & (4bytes for 32 & \\
 & bit OS) & \\
\hline
unsigned long & 8 bytes & 0 to 18446744073709551615\\
\hline
\end{tabular}
\end{center}

\subsection{Floating-point numbers:}
\label{sec:org4c1d766}
The following table provides the details of standard floating-point numbers with
storage sizes and value ranges and their precision:
\begin{center}
\begin{tabular}{l|l|l|l}
\hline
TYPE & STORAGE SIZE & VALUE RANGE & PRECISION\\
\hline
float & 4 bytes & 1.2E-38 to 3.4E+38 & 6 decimal places\\
\hline
double & 8 bytes & 2.3E-308 to 1.7E+308 & 15 decimal places\\
\hline
long double & 10 bytes & 3.4E-4932 to 1.1E+4932 & 19 decimal places\\
\hline
\end{tabular}
\end{center}

The header file <float.h> defines macros that allow you to use these values and
other details about the binary representation of real numbers in your programs.

\clearpage
\subsection{Void Types:}
\label{sec:org55efd68}
The void type specifies that no value is availabe. It is used in three
situtations:
\begin{center}
\begin{tabular}{l|l}
\hline
TYPE & DESCRIPTION / USE\\
\hline
Functions returns as void & There are various functions in C which do not return\\
 & any value or you can say they return void. A function\\
 & with no return value has the return type as void.\\
 & For example: \textbf{void exit(int status);}\\
\hline
Function arguments as void & There are various functions in C which do  not accept\\
 & any parameter. A function with no parameter can accept\\
 & a void.\\
 & For example: \textbf{int rand(void);}\\
\hline
Pointers to void & A pointer of type void * represents the address of an\\
 & object, but not it's type.\\
 & For example: a memory allocation function\\
 & void *malloc( size\textsubscript{t} size);\\
 & returns a pointer to void which can be casted to any\\
 & data type.\\
\hline
\end{tabular}
\end{center}

\subsection{Derived types:}
\label{sec:org66c6d8e}
The derived data types are basically derived out of the fundamental datatypes. A
derived data type won’t typically create a new data type – but would add various
new functionalities to the existing ones instead.

We can derive the derived data types out of the primitive data type by adding
some extra relationships to the elements that are available with the primitive
data types. We use the derived data types to represent multiple values as well
as single values in a program.

Below are the types of derived data types and their uses:
\begin{center}
\begin{tabular}{l|l}
\hline
TYPE & DECRIPTION / USE\\
\hline
arrays & refers to a sequence (ordered sequence) of a finite number of data items from\\
 & the same data type sharing one common name\\
\hline
function & refers to a self-contained block of single or multiple statements. It has it's\\
 & own specified name.\\
\hline
pointers & refers to a some special form of variables that one can use for holding\\
 & other variables' addresses.\\
\hline
structures & A collection of various different types of data type items that get stored in\\
 & a contagious type of memory allocation is known as structure in C.\\
\hline
\end{tabular}
\end{center}

\clearpage
\section{Variables:}
\label{sec:org3dbf7e5}
Variables are containers for storing data values, like numbers and
characters. Like mentioned previously there are different \textbf{data types} in
C. These data types are used to declare variable types.

\subsection{Syntax:}
\label{sec:org48f3612}
To create a variable specify the type and assign it a value.
\begin{center}
\begin{tabular}{llll}
\hline
type & variableName & = & value;\\
\hline
Example: &  &  & \\
int & myNum & = & 32;\\
\hline
\end{tabular}
\end{center}
The above example will create an integer variable called myNum with the value
of 15.

You can also declare a variable without assigning the value and assign it
later.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNum; //declare the variable

  myNum = 32; //assign a value to it
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Output variables:}
\label{sec:org02a8fd0}
To output variables in C you must use "format specifiers":
These are used together with the \textbf{printf()} function to tell the compiler what
data type the variable is.
A format specifier starts with the \textbf{\%} sign followed by a character.
The most common format specifiers are listed below:
\begin{center}
\begin{tabular}{l|l}
\hline
Format specifiers & Type of output\\
\hline
\%d or \%i & A decimal inter or signed integer\\
\hline
\%c & Signed character\\
\hline
\%f & Signed float\\
\hline
\%e & A floating-point number\\
\hline
\%s & A string or sequence of characters\\
\hline
\%lf & double\\
\hline
\%Lf & Long double\\
\hline
\%o & Octal integer\\
\hline
\%u & Short unsigned integer\\
\hline
\%ld & Long decimal integer\\
\hline
\%x & Hexadecimal integer\\
\hline
\%p & Print memory address in the\\
 & hexadecimal form\\
\hline
\end{tabular}
\end{center}

See examples of the uses of each below:

\subsubsection{\%d (Decimal Integer):}
\label{sec:org955a7c5}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int a=50;
  printf("The integer value of a is %d \n",a);
  return 0;
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{\%c (Character):}
\label{sec:org983b021}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  char myChar = 'a';

  printf("The first letter of the alphabet is: %c", myChar);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The first letter of the alphabet is: a
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{\%f (Floating Point):}
\label{sec:org2f20d1d}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  float a = 3;
  printf("The floating point of a is %f \n", a);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The floating point of a is 3.000000 
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{\%e (Floating Pointer Number):}
\label{sec:org09ec0a0}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  float a = 12.5;
  printf("The floating-point of a is %e\n", a);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The floating-point of a is 1.250000e+01
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{\%s (String):}
\label{sec:orge6f772f}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  char s[15] = "String";
  printf("The string value of s is %s\n", s);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The string value of s is String
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{\%lf (Double):}
\label{sec:org61f79cb}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  double d = 12.5;
  printf("The double value of d is %lf\n", d);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The double value of d is 12.500000
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{\%o (octal integer):}
\label{sec:org2dd8196}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int oct = 11;
  printf("The octal integer value of oct is %o\n", oct);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The octal integer value of oct is 13
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{\%x (Hexadecimal Integer):}
\label{sec:orgb5dbe00}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int h = 14;
  printf("The hexadecimal value of h is %x\n", h);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The hexadecimal value of h is e
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{\%p (Prints Memory Address):}
\label{sec:org76d46d1}
To find the memory address that holds values of a variable, we use the \%p format
specifier and it prints in hexadecimal form.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int sum = 0;
  printf("The memory address of sum is %p\n", &sum);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The memory address of sum is 0x7ffdf9e40ce4
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Changing variable values:}
\label{sec:org9b327b2}
\textbf{Note:} if you assign values to an existing variable, it will overwrite the
 previous value.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNum = 15; //myNum is 15
  myNum = 10;     //myNum is now 10

  printf("%d", myNum);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
10
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

You can also assign the value of one variable to another:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNum = 15;
  int myNumTwo = 23;

  //Assign the value of myNumTwo (23) to myNum
  myNum = myNumTwo;

  printf("myNum= %d\n", myNum);
  printf("myNumTwo= %d", myNumTwo);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
myNum= 23
myNumTwo= 23
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Add variables together:}
\label{sec:orgcb162a9}
To add variables together use the \textbf{+} operator:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x = 5;
  int y = 6;
  int sum = x + y;
  printf("%d", sum);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
11
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Declare multiple variables:}
\label{sec:org5282a61}
To declare more than one variable of the same type use a comma-seperated list:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x = 5, y = 6, z = 50;
  printf("%d", x + y + z);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
61
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
You can also assign the same value to multiple variables of the same type:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x, y, z;
  x = y = z = 50;
  printf("%d", x + y + z);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
150
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Variable names:}
\label{sec:org64e4db9}
All C variables must be identified with unique names.
These unique names are called \textbf{identifiers}.
Identifiers can be short names (like x and y) or more descriptive names (ages,
sum, totalVolume).
\textbf{Note:} It is recommended to use descriptive names in order to create
understandable and maintainable code:

The general rules for naming variables are:
\begin{itemize}
\item Names can contain letters, digits and underscores.
\item Names must begin with a letter or an underscore(\_).
\item Names are case sensitive.
\item Names cannot contain whitespaces or special characters like !, \#, \%, etc.
\item Reserved words (such as int) cannot be used as names.
\end{itemize}

\subsection{Real life example:}
\label{sec:orgdeb1626}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  #include <stdio.h>

int main(){
// Student data
int studentID = 15;
int studentAge = 23;
float studentFee = 75.25;
char studentGrade = 'B';

// Print variables
printf("Student id: %d\n", studentID);
printf("Student age: %d\n", studentAge);
printf("Student fee: %f\n", studentFee);
printf("Student grade: %c", studentGrade);
  }
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\clearpage
\section{Constants:}
\label{sec:org8e41afb}
To prevent a variable from being changed you can use the \textbf{const} keyword.
This will declare the variable as "constant", which means unchangeable and
read-only:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  const int myNum = 15; //myNum will always be 15
  myNum = 10; //Attempting to change the variable will output an error.
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

You should always declare the variable as constant when you have values that are
unlikely to change:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  const int minutesPerHour = 60;
  const float PI = 3.14;

  printf("Minutes per hour: %i\n", minutesPerHour);
  printf("PI: %f", PI);
}
\end{verbatim}
Output:
\begin{verbatim}
Minutes per hour: 60
PI: 3.140000
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Things to note:}
\label{sec:orge00c8d9}
When you declare a constant variable, it must be assigned with a value:
\textbf{Like this:}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  const int minutesPerHour = 60
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\textbf{This will not work:}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  const int minutesPerHour;
  minutesPerHour = 60; //error
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Another thing to note about constants is that it is considered good practice to
declare them in CAPS. It isn't required but makes your code more readable and
ensures that constant variables are easily distinguishable.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  const int BIRTHYEAR = 2023;
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\clearpage
\section{Operators:}
\label{sec:orgf50664a}
Operators are used to perform operations on variables and values.
In the example below, the \textbf{+} operator is used to add two values together.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNum = 1+2;
  printf("%i", myNum);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
3
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Although the \textbf{+} operator is often used to add together two values like in the
example above it can also be used to add together a variable and a value or a
variable and another variable:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int sum1 = 100 + 50; //150 
  int sum2 = sum1 + 250; //400
  int sum3 = sum2 + sum2; //800?

  printf("%i", sum3);
}
\end{verbatim}
Output:
\begin{verbatim}
800
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\subsection{Operator groups:}
\label{sec:org26ae17b}
C divides operators into the following groups:
\begin{itemize}
\item Arithmetic operators
\item Assignment operators
\item Comparison operators
\item Logical operators
\item Bitwise operators
\end{itemize}

\subsubsection{Arithmetic operators:}
\label{sec:org58d2e8e}
Arithmetic operators are used to  perfrom common mathematical operations.
\begin{center}
\begin{tabular}{l|l|l|l}
\hline
OPERATOR & NAME & DESCRIPTION & EXAMPLE\\
\hline
"+" & addition & Adds two values & x + y\\
\hline
"-" & subtraction & Subtracts one value from another & x - y\\
\hline
"*" & multiplication & Multiplies two values & x * y\\
\hline
"/" & division & Divides one value by another & x / y\\
\hline
\% & modulus & Returns the division remained & x \% y\\
\hline
++ & increment & Increases the value of a variable by 1 & ++x\\
\hline
-- & decrement & Decreases the value of a variable by 1 & --x\\
\hline
\end{tabular}
\end{center}

\subsubsection{Assignment operators:}
\label{sec:org686d866}
Assignment operators are used to assign values to variables.

\begin{center}
\begin{tabular}{l|l|l}
\hline
OPERATOR & EXAMPLE & SAME AS\\
\hline
"=" & x = 5 & x =5\\
\hline
"+=" & x += 3 & x = x + 3\\
\hline
"-=" & x -= 3 & x = x - 3\\
\hline
"*=" & x *= 3 & x = x * 3\\
\hline
"/=" & x /= 3 & x = x / 3\\
\hline
"\%=" & x \%= 3 & x = x \% 3\\
\hline
"\&=" & x \&= 3 & x = x \& 3\\
\hline
"\^{}=" & x \^{}=3 & x = x \^{} 3\\
\hline
">>=" & x >>= 3 & x = x >> 3\\
\hline
"<<=" & x <<= 3 & x = x << 3\\
\hline
\end{tabular}
\end{center}

\subsubsection{Comparison operators:}
\label{sec:org2430962}
Comparison operators are used to compare two values (or variables). This is
important in programming, because it helps us to find answers and make
decisions.
\begin{center}
\begin{tabular}{l|l|l}
\hline
OPERATOR & NAME & EXAMPLE\\
\hline
"==" & Equal to & x == y\\
\hline
"!=" & Not equal & x != y\\
\hline
">" & Greater than & x > y\\
\hline
"<" & Less than & x < y\\
\hline
">=" & Greater than or equal to & x >= y\\
\hline
"<=" & Less than or equal to & x <= y\\
\hline
\end{tabular}
\end{center}

The return value of a comparison is either 1 or 0, which means true(1) or
false(0). These values are known as \textbf{Boolean values}. The boolean concept is
better explained in the \textbf{booleans and if\ldots{}else} sections.

\subsubsection{Logical operators:}
\label{sec:org2f6a640}
You can also test for true or false with logical operators.
Logical operators are used to determine the logic between variables or values:
\begin{center}
\begin{tabular}{l|l|l|l}
\hline
OPERATOR & NAME & DESCRIPTION & EXAMPLE\\
\hline
"\&\&" & Logical and & Returns true if both & x < 5 \&\& x < 10\\
 &  & statements are true & \\
\hline
"!" & Logical not & Reverse the result, & !(x < 5 \&\& x < (10)\\
 &  & returns false if the & \\
 &  & result is true & \\
\hline
\end{tabular}
\end{center}

\subsubsection{Sizeof operator:}
\label{sec:org7f78631}
The memory size (in bytes) of a data type or a variable can be found with the
\textbf{sizeof} operator:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myInt;
  float myFloat;
  double myDouble;
  char myChar;

  printf("%lu\n", sizeof(myInt));
  printf("%lu\n", sizeof(myFloat));
  printf("%lu\n", sizeof(myDouble));
  printf("%lu\n", sizeof(myChar));

}
\end{verbatim}
Output:
\begin{verbatim}
4
4
8
1
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\textbf{Note:} the \textbf{\%lu} format specifier is used to print the result, instead of
 \&d. This is because the compiler expects the sizeof operator to return a \textbf{long
 unsigned int} (\%lu) instead of int (\%d).

\clearpage
\clearpage
\section{Booleans:}
\label{sec:org8f69de6}
Very often in  programming you will need a data type that can only have one of
two values, like:
\begin{itemize}
\item YES / NO
\item ON / OFF
\item True / FALSE
\end{itemize}
For this, C has a bool data type, which is known as booleans.
Booleans represent data values that are either true or false.

\subsection{Boolean variables:}
\label{sec:org6e76591}
In C, the bool type is not a built-in data type, like int or char.
It was introduced in C99 and must be imported with the following header file to
be used:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdbool.h>
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

A boolean variable is declared with the \textbf{bool} keyword and can only take the
values true or false:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(){
  bool isProgrammingFun = true;
  bool isFishTasty = false;

  printf("%d\n", isProgrammingFun); //Returns 1 (true)
  printf("%d", isFishTasty);      //Returns 0 (false)
}
\end{verbatim}
Output:
\begin{verbatim}
1
0
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\textbf{Note:} boolean values are returned as integers:
\begin{itemize}
\item 1 (or any number that isn't 0) represents true
\item 0 represents false
\end{itemize}
Therefore, you must use the \%d format specifier to print a boolean variable.

\subsection{Comparing Values and Variables:}
\label{sec:orgaff9972}
Comparing values can be very  useful in programming, because it helps us find
answers and make decisions.
For example, you can use a comparison operator, such as greater than (>) to
compare two values:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(){
  printf("%d", 10 > 9); //Returns 1 (true) because 10 is greater than 9
}
\end{verbatim}
Output:
\begin{verbatim}
1
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In the same way you can compare two variables:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(){
  int x = 10;
  int y = 9;
  printf("%d", x > y);
}
\end{verbatim}
Output:
\begin{verbatim}
1
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In the example below, the equal to (==) operator is used to compare different
values:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(){
  printf("%d", 10 == 10); //Returns 1 because 10 is equal to  10
  printf("%d", 10 == 15); //Returns 0 because 10 is not equal to 15
}
\end{verbatim}
Output:
\begin{verbatim}
10
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
You are not limited to only compare numbers, You can compare variables or even
special structures like arrays:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(){
  bool isProgrammingFun = true;
  bool isProgrammingTasty = false;

  //find out if both statements are true:
  printf("%d", isProgrammingFun == isProgrammingTasty);
}
\end{verbatim}
Output:
\begin{verbatim}
0
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Real life example:}
\label{sec:org96505c4}
This example checks if a person is old enough to vote.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(){
  int myAge = 22;
  int votingAge = 18;

  if (myAge >= votingAge) {
  printf("Old enough to vote!");
  } else {
  printf("Not old enough to vote.");
    }
}
\end{verbatim}
Output:
\begin{verbatim}
Old enough to vote!
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\clearpage
\clearpage
\section{if Statements:}
\label{sec:org801cdc8}
In C there are several types of \textbf{'if'} statements that are used to control the
flow of execution in a program. The main difference between the different types
of 'if' statements is in their syntax and how they are used in different
situations.
Here are the different types of 'if' statements and their syntax:
\subsection{Conditions and if statements:}
\label{sec:orgb727165}
In previous sections the use of logical conditions were mentioned:
\begin{itemize}
\item Less than: a < b
\item Less than or equal to: a  <= b
\item Greater than: a > b
\item Greater than or equal to: a >= b
\item Equal to: a == b
\item Not equal to: a != b
\end{itemize}

In C programming, conditional statements are used to perfrom different actions
based on different conditions.
C has the following conditional statements:
\begin{itemize}
\item Use \textbf{if} to specify a block of code to be executed if a specified condition is
\textbf{true}
\item Use \textbf{else} to specify a block of code to be executed, if the same condition is
\textbf{false}
\item Use \textbf{else if} to specify a new condition to test, if the first condition is
\textbf{false}
\item Use \textbf{switch} to specify many alternative blocks of code to be executed
\end{itemize}

\subsection{if Statement:}
\label{sec:org88203ff}
The "\textbf{if}" statement is used for making decisions based on certain
conditions. It allows a program to execute different statements based on whether
a specified condition is true or false.

\subsubsection{Syntax and examples:}
\label{sec:org8a795a4}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
if (condition) {
  //code to be executed if the condition is true
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

The \textbf{"condition"} is an expression that is evaluated to either true or false. If
the "\textbf{condition"} is true then the code inside the curly braces is executed,
otherwise the code is skipped.
For example:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x = 5;
  if (x > 3) {
    printf("x is greater than 3");
  }
}
\end{verbatim}
Output:
\begin{verbatim}
x is greater than 3
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the \textbf{"if"} statement check if "\textbf{x}" is greater than 3. Since
\textbf{x} is indeed greater than 3, the message "x is greater than 3" is printed in
the output.

\subsection{if \ldots{} else Statement:}
\label{sec:org3b318f0}
The \textbf{'if else'} statement is used for making decisions based on certain
conditions. It allows a program to execute different statements based on whether
a specified condition is true or false. The '\textbf{if else}' statement provides an
alternative execution path if the condition is false.

\subsubsection{Syntax and examples:}
\label{sec:org145a5d8}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
if (condition) {
  //condition to be if the condition is true
} else {
  //code to be executed if the condition is false
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
The '\textbf{condition}' is an expression that is evaluated to either true or false. If
the '\textbf{condition}' is true, then the code inside the first block of curly
braces is executed, otherwise the code inside the inside the second block of
curly braces is executed.
For example:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x = 5;
  if (x > 3 ) {
    printf("x is greater than 3");
  } else {
    printf("x is less than or equal to 3");
  }
}
\end{verbatim}
Output:
\begin{verbatim}
x is greater than 3
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example the '\textbf{if}' statements checks if '\textbf{x}' is greater than 3. Since
'\textbf{x}' is indeed greater than 3, the message "x is greater than 3" is printed in
the output. If '\textbf{x}' were less than or equal to 3, the message "x is less than
or equal to 3" would be outputted instead.

The '\textbf{if else}' statement can also be nested, which means that an '\textbf{if else}'
statement can be placed inside another '\textbf{if else}' statement. This is useful for
testinng multiple conditions. The syntax for a nested '\textbf{if else}' statement is
as follows:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
if (condition) {
//code to be executed if condition is true
} else if (condition2) {
//code to be executed if condition1 is false and condition2 is true
} else {
//code to be executed if both condition1 and condition2 are false
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
For example:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>
  int main() {
    int x = 5;
    int y = 2;
    if (x > 3) {
      if (y > 1) {
      printf("x is greater than 3 and y is greater than 1");
      } else {
      printf("x is greater than 3 but y is less than or equal to 1");
      }
    } else {
      printf("x is less than or equal to 3");
    }
  }
\end{verbatim}
Output:
\begin{verbatim}
x is greater than 3 and y is greater than 1
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example the out '\textbf{if}' statement checks if '\textbf{x}' is greater
than 3. Since '\textbf{x}' is greater than 3, the inner '\textbf{if else}' statement is
executed, which checks if '\textbf{y}' is greater than 1. Since '\textbf{y}' is greater than
1, the message "x is greater than 3 and y is greater than 1" is printed in the
console. If "\textbf{y}' were less than or equal to 1, the message "x is greater than 3
but y is less than or equal to 1" would be printed instead. If '\textbf{x}' were less
than or equal to 3, the message "x is less than or equal to 3" would be printed
instead.

\subsection{else \ldots{} if Statement:}
\label{sec:org070df4f}
In C the '\textbf{else if}' statement is used to test multiple conditions in
sequence. It allows a program to executre different statments based on different
conditions in a hierarchical manner. The '\textbf{else if}' statement is placed after
an initial '\textbf{if}' statement and before the '\textbf{else}' statement.

\subsubsection{Syntax and examples:}
\label{sec:org8493541}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
if (condition1) {
//code to be executed if condition1 is true
} else if (condition2) {
//code to be executed if condition1 is false and condition2 is true
} else {
//code to be executed if both condition1 and condition2 are false
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

In this syntax, '\textbf{condition1}' is the initial condition that is tested in the
'\textbf{if}' statement. If '\textbf{condition1}' is false, the '\textbf{else if}' statement is
executed and the program tests the second condition '\textbf{condition2}'. If
'\textbf{condition2}' is true, then the code inside the second block of curly braces is
executed, otherwise, the code inside the third block of curly braces is
executed.

Here is an example of the '\textbf{else if}' statement:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int score = 85;

  if (score >= 90) {
	  printf("You got an A");
  } else if (score >= 80) {
    printf("You got a B");
  } else if (score >= 70) {
    printf("You got a C");
  } else if (score >= 60) {
    printf("You got a D");
  } else {
    printf("You failed");
  } 			      }
\end{verbatim}
Output:
\begin{verbatim}
You got a B
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the program checks the value of the 'score' variable and prints
a message depending on the score. The 'if' statements test if the score is
greater than or equal to 90. If it is, the message "You got an A" is printed. If
not, the next 'else if' statement is executed, which tests if the score is
greater than or equal to 80. If it is, the message "You got a B" is
printed. This process repeats for each 'else if' statement until a condition is
met. If none of the conditions are met, the message "you failed" is printed.

Note that in the example aboce each 'else if' statement is nested inside the
previous one. This creates a sequence of conditions that are tested one after
the other, allowing the program to choose the apporopriate message to print
based on the value of the 'score' variable.

\subsection{Short hand if \ldots{} else:}
\label{sec:orgb12a709}
There is also a shorthand if else, which is known as the ternary operator\footnote{Operand: a term used to refer to a value or a variable that is operated
on by an operator.}
because it consists of three operands\footnote{Operator is a symbol that performs some operation on one
or more operands to produce a result.}. The shorthand 'if-else' statement
is a compact way of writing an 'if-else' statement that consists of a single
line of code for each condition. It is also known as a conditional operator.

\subsubsection{Syntax:}
\label{sec:org7ea93d4}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
(condition) ? expression1 : expression2;
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this syntax 'condition' is the condtition that is tested, 'expression' is the
expression that is evaluated if this condition is true, and 'expression2' is the
expression that is evaluated if the condition is false.

Here's an example:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int score = 85;
  char grade = (score >= 60) ? 'P' : 'F';
  printf("Your grade is %c", grade);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
Your grade is P
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the program checks the value of the 'score' variable and
assigns the grade 'P' if the score is greater than or equal to 60, and 'F'
otherwise. The shorthand 'if-else' statement is used to evaluate the condition
and assign the apporopriate grade to the 'grade' variable.

Note that the shorthand 'if-else' statement is often used in situations where a
simple condition needs to be tested and the result of the condition needs to be
assigned to a variable. However, it can also be used in more complex
expressions, such as nested expressions or expressions involving multiple
operators.

It's important to note that the shorthand 'if-else' statement should be used
judiciously, as it can make code more difficult to read and understand if used
excessively. It's generally best to use the full 'if-else' statement for more
complex conditions and the shorthand 'if-else' statement for simpler conditions.














\section{Switch statement:}
\label{sec:org3b571dc}
Instead of writing many 'if \ldots{} else' statements, you can use the switch
statement.

The 'switch' statement is a control statement that allows the execution of
different sections of code depending on the value of a variable or an
expression. The 'switch' statement is commonly used when there are many possible
cases to consider, and it provides a more concise and readable way to express
complex conditional logic than a series of nested 'if' statements.

\subsection{Syntax:}
\label{sec:org0325919}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  switch (expression) {
   case constant1:
     //statements to be executed if expression == constant1
     break;
   case constant2:
    //statements to be executed if expression == constant2
     break;


   case constantN:
     //statements to be executed if expression == constantN
     break;
   default:
     //statements to be executed if none of the above cases are ture
     break;
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this syntax, 'expression' is the variable or expression that is being tested,
and 'constant1' to 'constantN' are the values or expressions that are being
compared to the value of 'expression'. If the value of 'expression' matches one
of the constants, the statements inside that case block are executed. If none of
the cases match, the statements inside the 'default' block are executed.

\begin{itemize}
\item The 'switch' expression is evaluated once
\item The value of the expression is compared with the values of each 'case'
\item If there is a match, the associated block of code is executed
\item The 'break' statement breaks out of the switch block and stops the execution
\item The 'default' statement is optional, and specifies some code to run if there
is no case match.
\end{itemize}

\subsection{Example:}
\label{sec:org0b30693}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  char grade = 'B';

  switch (grade) {
  case 'A':
      printf("Excellent!\n");
      break;
  case 'B':
    printf("Good job!\n");
    break;
  case 'C':
    printf("Needs improvement.\n");
    break;
  case 'D':
    printf("Invalid grade.\n");
    break;
  }
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
Good job!
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the program check the value of the 'grade' variable using a
'switch' statement and prints a message depending on the value of 'grade'. If
the value of 'grade' is 'A', the program prints "Excellent!". If the value of
'grade' is 'B', the program prints "Good job!". If the value of 'grade' is 'C',
the program prints "Needs improvement.". If the value of 'grade' is anything
else, the program prints "Invalid grade.".

Note that each case block must end with a 'break' statement. This is because the
'switch' statement will continue to execute the statements in the subsequent
case blocks until it encounters a 'break' statement. The 'default' block is
optional and it is executed if none of the cases match. It is recommended to
always include a 'default' block to handel unexpected cases.

\subsubsection{'Break' keyword:}
\label{sec:orgf4dea88}
When C reaches a break keyword, it breaks out of the switch block.
This will stop the execution of more code and case testing inside the block.
When a match is found and the job is done, it's time for a break. There is no
need for more testing.

Note: a break can save a lot of execution time because it "ignore" the execution
of all the rest of the code in the switch block.
\subsubsection{'Default' keyword:}
\label{sec:orgf1426f4}
The 'default' keyword specifies some code to run if there is no case match:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
    #include <stdio.h>

int main(){
      int day = 4;

      switch (day) {
    case 6:
      printf("Today is Saturday");
      break;
    case 7:
      printf("Today is Sunday");
      break;
    default:
      printf("Looking forward to the Weekend");
  }

  // Outputs "Looking forward to the Weekend"
    }
\end{verbatim}
Output:
\begin{verbatim}
Looking forward to the Weekend
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Note: The default keyword must be used as the last statement in the switch, and
it does not need a break.

\section{Loops:}
\label{sec:org2d11ee1}
Loops can execute a block of code as long as a specified condition is reached.
Loops are handy because they save time, reduce errors, and they makde code more
readable.

There are 3 types of loops in C: 'for', 'while', and 'do-while'.

\subsection{for Loop:}
\label{sec:org6386143}
The 'for' loops is a control flow statement that repeatedly executes a block of
code as long as a particular condition is true. The syntax is as follows:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
for (initialization; condition; increment/decrement) {
  //statment to be executed
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
The initialization step initializes a loop counter variable and the condition is
evaluated at the beginning of each iteration. If the condition is true, the
statements inside the loop are executed. After executing the statements, the
increment/decrement statement is executed and the condition is evaluated
again. The loop continues until the condition becomes false.

\begin{itemize}
\item Statement 1 is executed (one time) before the execution of the code block.
\item Statement 2 defines the condition for executing the code block.
\item Statement 3 is executed (every time) after the code block has been executed.
\end{itemize}

Here's an example:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  for (int i = 0; i < 10; i++) {
      printf("%d\n", i);
      }
    }
\end{verbatim}
Output:
\begin{verbatim}
0
1
2
3
4
5
6
7
8
9
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{while Loop:}
\label{sec:orgeeb23ee}
\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
while (condition) {
    // statements to be executed
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
The condition is evaluated at the beginning of each iteration. If the condition
is true, the statements inside the loop are executed. After executing the
statements, the condition is evaluated again. The loop continues until the
condition becomes false.
Here's an example:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

  int main(){
	int i = 0;
	while (i < 10) {
	printf("%d\n", i);
	i++;
    }
      }
\end{verbatim}
Output:
\begin{verbatim}
0
1
2
3
4
5
6
7
8
9
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{do-while Loop:}
\label{sec:org94142a7}
The do-while loop is a control flow statement that repeatedly executes a block
of code as long as a particular condition is true. The syntax of the do-while
loop is as follows:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
do {
    // statements to be executed
} while (condition);
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
The statements inside the loop are executed at least once, and then the
condition is evaluated. If the condition is true, the statements inside the loop
are executed again. The loop continues until the condition becomes false.
Here's an example:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

  int main(){
    int i = 0;
    do {
      printf("%d\n", i);
      i++;
    } while (i < 10);
  }
\end{verbatim}
Output:
\begin{verbatim}
0
1
2
3
4
5
6
7
8
9
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Loops are useful when you need to perform the same operation multiple times, or
when you need to iterate over a collection of data. It's important to make sure
that the loop condition will eventually become false, otherwise the loop will
continue indefinitely, resulting in an infinite loop.

\subsection{Nested Loops:}
\label{sec:org14796c6}
Nested loops in C are loops that are placed inside another loop. This allows you
to perform more complex operations that require multiple iterations.

The basic syntax for a nested loop in C is as follows:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
for (initialization; condition; increment/decrement) {
    for (initialization; condition; increment/decrement) {
	// statements to be executed
    }
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the outer loop controls the iteration of the inner loop. The
statements inside the inner loop will be executed for each iteration of the
outer loop.

Here's an example of a nested loop that prints out a multiplication table:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  #include <stdio.h>

  int main(){
    for (int i = 1; i <= 10; i++) {
    for (int j = 1; j <= 10; j++) {
	printf("%d ", i*j);
    }
    printf("\n");
}
  }
\end{verbatim}
Output:
\begin{verbatim}
1 2 3 4 5 6 7 8 9 10 
2 4 6 8 10 12 14 16 18 20 
3 6 9 12 15 18 21 24 27 30 
4 8 12 16 20 24 28 32 36 40 
5 10 15 20 25 30 35 40 45 50 
6 12 18 24 30 36 42 48 54 60 
7 14 21 28 35 42 49 56 63 70 
8 16 24 32 40 48 56 64 72 80 
9 18 27 36 45 54 63 72 81 90 
10 20 30 40 50 60 70 80 90 100 
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
It's important to note that nested loops can significantly increase the
execution time of a program, especially if the inner loop is executed many
times. Therefore, it's important to carefully consider whether a nested loop is
the best solution for a particular problem, or if there is a more efficient way
to achieve the same result.










\section{Break and Continue:}
\label{sec:org080a583}
\subsection{Break:}
\label{sec:org6cfaf99}
The 'break' statement is a control statement that is used to exit a loop or
switch statement. When the 'break' statement is encountered the program jumps
out of the loop or switch statement, regardless of whether the loop condition or
switch case condition is still true.

In a previous example the 'break' statement was used to jump out of a 'switch'
statement.

Below is an example of break used to jump out of a for loop where it is used to
jump out when i is equal to 4:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int i;

  for (i = 0; i < 10; i++) {
    if (i == 4) {
      break;
      }
    printf("%d\n", i);
    }
}
\end{verbatim}
Output:
\begin{verbatim}
0
1
2
3
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Here is an example of using 'break' in a 'switch' statement:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int day = 3;
  switch (day) {
  case 1:
      printf("Monday");
      break;
  case 2:
      printf("Tuesday");
      break;
  case 3:
      printf("Wednesday");
      break;
  default:
    printf("Invalid day");
  }
}
\end{verbatim}
Output:
\begin{verbatim}
Wednesday
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the switch statement evaluates the value of the variable day,
and executes the appropriate case statement. When day is equal to 3, the code
inside the case 3: block is executed. After the code is executed, the break
statement is encountered, which causes the program to exit the switch statement
and continue with the rest of the program.

In summary, the break statement is a useful tool for controlling the flow of a
program, and can be used to exit loops or switch statements when certain
conditions are met.



\subsection{Continue:}
\label{sec:org0a7cb47}
The 'continue' statement is a control statement that is used to skip the current
iteration of a loop and move on to the next iteration. When the 'continue'
statement is encountered inside a loop, the program skips over any remaining
statements in the loop for that iteration and goes directly to the next
iteration.

Below is an example of using 'continue' in a 'for' loop:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  #include <stdio.h>

  int main(){
    for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
	continue;
    }
    printf("%d\n", i);
}
  }
\end{verbatim}
Output:
\begin{verbatim}
1
3
5
7
9
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the loop will execute 10 times, with the variable i starting at
0 and increasing by 1 each time through the loop. However, when i is an even
number (i.e., when i \% 2 == 0 is true), the continue statement is executed,
which causes the program to skip over the remaining statements in the loop for
that iteration and move directly to the next iteration. This means that the
printf statement is only executed for odd numbers.


Here's another example of using continue in a while loop:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  #include <stdio.h>

  int main(){
    int i = 0;
    while (i < 10) {
    i++;
    if (i % 2 == 0) {
	continue;
    }
    printf("%d\n", i);
}
  }
\end{verbatim}
Output:
\begin{verbatim}
1
3
5
7
9
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the loop will continue to execute as long as i is less
than 10. The variable i is incremented by 1 at the beginning of each
iteration. However, when i is an even number, the continue statement is
executed, which causes the program to skip over the remaining statements in the
loop for that iteration and move directly to the next iteration. This means that
the printf statement is only executed for odd numbers.


In summary, the continue statement is a useful tool for controlling the flow of
a loop, and can be used to skip over certain iterations when certain conditions
are met.

\section{Arrays:}
\label{sec:orgc4fc6bb}
An array is a collection of elements of the same data type, stored in contiguous
memory locations in C. Each element in the array is accessed using an index,
which is an integer value that represents the position of the element in the
array. The first element in the array has an index of 0, and the last element
has an index of n-1, where n is the size of the array.


Here's an example of creating and accessing an array in C:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
	#include <stdio.h>

int main(){
 int numbers[5];   // creates an array of 5 integers

 numbers[0] = 10;  // assigns 10 to the first element of the array
 numbers[1] = 20;  // assigns 20 to the second element of the array
 numbers[2] = 30;  // assigns 30 to the third element of the array
 numbers[3] = 40;  // assigns 40 to the fourth element of the array
 numbers[4] = 50;  // assigns 50 to the fifth element of the array

 printf("%d\n", numbers[2]);   // prints the value of the third element of the array (30)

	}
\end{verbatim}
Output:
\begin{verbatim}
30
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, we create an array of 5 integers called numbers, and assign
values to each element of the array. We then use the index notation numbers[2]
to access the third element of the array, which has a value of 30.


Arrays can also be initialized at the time of creation, like this:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
int numbers[5] = {10, 20, 30, 40, 50};
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, we create an array of 5 integers called numbers and initialize
each element with a value.


Arrays can also be used to represent multi-dimensional data, such as
matrices. In a two-dimensional array, each element is identified by two indices:
a row index and a column index. The elements are stored in row-major order,
meaning that the elements of each row are stored together in contiguous memory
locations.


Here's an example of creating and accessing a two-dimensional array in C:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  #include <stdio.h>

  int main(){
    int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

printf("%d\n", matrix[1][2]);  // prints the value of the element in
			       //the second row and third column (6)

  }
\end{verbatim}
Output:
\begin{verbatim}
6
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, we create a 3x3 matrix called matrix, and initialize each
element with a value. We then use the index notation matrix[1][2] to access the
element in the second row and third column, which has a value of 6.


Arrays in C are a powerful tool for storing and manipulating collections of data
of the same type, and are widely used in many different programming
applications.

\subsection{Change an Array Element:}
\label{sec:orgaf397eb}
To change the value of a specific element, refer to the index number:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
myNumbers[0] = 33;
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNumbers[] = {25, 50, 75, 100};
	myNumbers[0] = 33;

	printf("%d", myNumbers[0]);

    // Now outputs 33 instead of 25
      }
\end{verbatim}
Output:
\begin{verbatim}
33
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsection{Loop through an array:}
\label{sec:org6232204}
You can loop through the array elements with a 'for' loop.
The following example outputs all elements in the myNumbers array:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  #include <stdio.h>

  int main(){
    int myNumbers[] = {25, 50, 75, 100};
    int i;

    for (i = 0; i < 4; i++) {
      printf("%d\n", myNumbers[i]);
}
  }
\end{verbatim}
Output:
\begin{verbatim}
25
50
75
100
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\section{Strings:}
\label{sec:org6c4e2f9}
A string is a sequence of characters that are stored in an array. A string is
represented as an array of characters terminated by a null character, which is a
character with the ASCII value of 0.

For example, the string "Hello, world!" would be represented in C as an array of
characters:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  char str[] = "Hello, world!";
  printf("%s", str);
}
\end{verbatim}
Output:
\begin{verbatim}
Hello, world!
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

In the above example 'str' is an array of characters with a size of 14, which
includes the 13 characters of the string plus the null character that terminates
the string.

Strings in C can be manipulated using various standard library functions that
are defind in the 'string.h' header file. Some of the commonly used string
functions include:
\begin{itemize}
\item 'strlen()' - Returns the length of a string.
\item 'strcpy()' - Copies a string to another string.
\item 'strcat()' - Concatenates two strings.
\item 'strcmp()' - Compares two strings.
\end{itemize}

Here is an example of using the 'strlen()' function:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "Hello, world!";
    int length = strlen(str);
    printf("Length of string: %d\n", length);
    return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
Length of string: 13
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\subsection{Modify strings:}
\label{sec:org4407c62}
To change the value of a specific character in a string, refer to the index
number, and use single quotes:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  #include <stdio.h>

  int main(){
    char greetings[] = "Hello World!";
    greetings[0] = 'J';
    printf("%s", greetings);
// Outputs Jello World! instead of Hello World!
  }
\end{verbatim}
Output:
\begin{verbatim}
Jello World!
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\subsection{Loop Through a String:}
\label{sec:orgc2a93a6}
In the same way you loop through an array, it can be done to loop through a
string:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
  #include <stdio.h>

  int main(){
char carName[] = "Volvo";
int i;

for (i = 0; i < 5; ++i) {
  printf("%c\n", carName[i]);
}
  }
\end{verbatim}
Output:
\begin{verbatim}
V
o
l
v
o
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\subsection{Alternate Way of Creating Strings:}
\label{sec:orgd8a5a95}
In the examples above, we used a "string literal" to create a string
variable. This is the easiest way to create a string in C.


You should also note that you can create a string with a set of characters. This
example will produce the same result as the example in the beginning of this
page:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
char greetings[] = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!', '\0'};
printf("%s", greetings);
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\textbf{Note:} The '$\backslash$0$\backslash$ character at the end is known as a "null terminating
character", This tells C that it is the end of the string.

\subsection{Special Characters in String:}
\label{sec:org356ecc2}
Because strings must be written within quotes, C will misunderstand this string,
and generate an error:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
char txt[] = "We are the so-called "Vikings" from the north.";
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
The solution to avoid this problem, is to use the backslash escape character.

The backslash ($\backslash$) escape character turns special characters into string
characters:
\begin{center}
\begin{tabular}{l|l|l}
\hline
ESCAPE CHARACTER & RESULT & DESCRIPTION\\
\hline
$\backslash$' & ' & Single quote\\
\hline
$\backslash$" & " & Double quote\\
\hline
$\backslash$\ & $\backslash$ & Backslash\\
\hline
\n &  & New line\\
\hline
\t &  & Tab\\
\hline
$\backslash$0 &  & Null\\
\hline
\end{tabular}
\end{center}

So the correct way to type the above example would be:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
char txt[] = "We are the so-called \"Vikings\" from the north.";
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\subsection{String functions:}
\label{sec:orgca357c6}
In C, strings are represented as arrays of characters, terminated by a null
character ($\backslash$0). There are various standard library functions that are defined in
the string.h header file that allow you to manipulate strings. Here are some
commonly used string functions in C:

\subsubsection{'strlen()'}
\label{sec:orgdb723b0}
Returns the length of a string. This function takes a string as input and
returns the number of characters in the string, excluding the null character.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <string.h>

int main(){
  char str[] = "Hello, world!";
  int len = strlen(str);
  printf("The length of the string is %d\n", len);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The length of the string is 13
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}

\subsubsection{'strcpy()'}
\label{sec:org4a6b8b9}
Copies one string to another. This function takes two strings as input, and
copies the contents of the second string into the first string.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <string.h>

  int main(){
    char src[] = "Hello, world!";
    char dest[20];
    strcpy(dest, src);
    printf("The copied string is %s\n", dest);
    return 0;
  }
\end{verbatim}
Output:
\begin{verbatim}
The copied string is Hello, world!
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\subsubsection{'strcat()'}
\label{sec:orgfedb22f}
Concatenates two strings. This function takes two strings as input, and appends
the contents of the second string to the end of the first string.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <string.h>

int main(){
  char str1[20] = "Hello, ";
  char str2[] = "world!";
  strcat(str1, str2);
  printf("The concatenated string is %s\n", str1);
  return 0;
}
\end{verbatim}
Output:
\begin{verbatim}
The concatenated string is Hello, world!
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\subsubsection{'strcmp()'}
\label{sec:orgf9cd828}
Compares two strings. This function takes two strings as input and returns an
integer value that indicates the lexicographic relationship between the two
strings.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>
#include <string.h>

int main(){
  char str1[] = "Hello, world!";
  char str2[] = "Hello, World!";
  int cmp = strcmp(str1, str2);
  if(cmp == 0) {
    printf("The strings are equal\n");
    } else if(cmp < 0) {
    printf("The first string is less than the second string\n");
    } else {
    printf("The first string is greater than the second string\n");
    }
}
\end{verbatim}
Output:
\begin{verbatim}
The first string is greater than the second string
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
These are just a few of the many string functions available in C, It's important
to read the documentation carefully to understand how to use each function
correctly.

\section{User Input:}
\label{sec:org7716e79}
In C, you can read user input from the keyboard using the scanf() function. This
function reads input from the standard input stream (stdin) and stores the
values in variables.


Here is an example of how to use scanf() to read a single integer from the user:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
    int num;
  printf("Enter a number: ");
  scanf("%d", &num);
  printf("You entered: %d\n", num);
  return 0;
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the printf() function is used to prompt the user to enter a
number, and the scanf() function is used to read the number from the keyboard
and store it in the num variable. The format specifier \%d tells scanf() to read
an integer value, and the \& operator is used to pass the address of the variable
num to scanf().


Here is an example of how to use scanf() to read multiple values from the user:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int num1, num2;
  printf("Enter two numbers: ");
  scanf("%d %d", &num1, &num2);
  printf("You entered: %d and %d\n", num1, num2);
  return 0;
}
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the scanf() function is used to read two integer values
separated by a space. The values are stored in the variables num1 and num2,
respectively.

Note that scanf() can be tricky to use correctly, especially when reading
strings or other types of data that require more complex input formatting.

'scanf()' has some serious limitations regarding strings. One being that it
considers space (whitespace, tabs, etc) as terminating characters, which means
that it will only display a single word (even if you input many words).
That is why when working with strings it is at times better to use 'fgets()' to
read a line of text. Note that you must include the following arguments:
\begin{itemize}
\item name of the string variable
\item sizeof (string\textsubscript{name})
\item stdin
\end{itemize}

\section{Memory Address:}
\label{sec:org035a7f1}
In C, memory addresses are used to refer to specific locations in the computer's
memory. Every variable declared in a C program has a memory address associated
with it. You can think of a memory address as a unique identifier that tells the
program where a particular value is stored in memory.
When a variable is created in C, a memory address is assigned to the variable.
The memory address is the location of where the variable is stored on the computer.
When we assign a value to the variable, it is stored in this memory address.

Memory addresses are represented as hexadecimal numbers in C. For example, the
memory address of a variable called x can be obtained using the \& operator, like
this:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x = 42;
  printf("The address of x is: %p\n", &x);
}
\end{verbatim}
Output:
\begin{verbatim}
The address of x is: 0x7ffd2d641154
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the \%p format specifier is used to print the memory address of
x in hexadecimal format. The \& operator is used to obtain the address of x and
pass it to printf().


You can also use pointers in C to work with memory addresses directly. A pointer
is a variable that stores the memory address of another variable. Here is an
example of how to declare a pointer and initialize it with the address of a
variable:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x = 42;
  int *ptr = &x;
  printf("The value of x is: %d\n", *ptr);
}
\end{verbatim}
Output:
\begin{verbatim}
The value of x is: 42
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the * operator is used to declare ptr as a pointer to an
integer. The address of x is obtained using the \& operator and stored in ptr.

You can use pointers to access the value stored at a particular memory
address. The * operator is used to dereference a pointer and obtain the value
stored at the memory address it points to.

In this example, the * operator is used to dereference ptr and obtain the value
stored at the memory address it points to. The output of the printf() statement
will be The value of x is: 42.

Working with memory addresses and pointers can be tricky and requires a good
understanding of how memory works in the computer. It's important to be careful
when working with memory addresses and avoid common errors like dereferencing a
null pointer or accessing memory that is out of bounds.

\subsection{Why is it useful to know the memory address?}
\label{sec:org2e11423}
\textbf{Pointers} are important in C, because they allow us to manipulate the data in
the computer's memory - this can reduce the code and improve the performance.

Pointers are one of the things that makes C stand out from other programming
languages.

\section{Pointers:}
\label{sec:org4c7a62f}
In the previous section pointers were briefly mentioned with regards to memory
addresses.

A pointer is a variable that stores the memory address of another
variable. Pointers provide a way to work with memory addresses and access the
values stored at those addresses directly.

To declare a pointer variable, you use the * operator in the variable
declaration. For example, to declare a pointer to an integer variable x, you
would use the following syntax:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
int *prt;
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
This declares a pointer variable called ptr that can store the memory address of
an integer value. The * operator is used to indicate that ptr is a pointer
variable.

To initialize a pointer variable with the memory address of a variable, you use
the \& operator. For example, to initialize ptr with the memory address of x, you
would use the following syntax:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int x = 42;
  int *ptr = &x;
  printf("The value of x is: %d\n", *ptr);
}
\end{verbatim}
Output:
\begin{verbatim}
The value of x is: 42
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
This initializes ptr with the memory address of x. The \& operator is used to
obtain the memory address of x, which is then assigned to ptr.

To access the value stored at the memory address pointed to by a pointer
variable, you use the * operator again.

This dereferences ptr using the * operator and prints the value stored at the
memory address pointed to by ptr, which is the value stored in x.

Pointers can be used for a wide variety of purposes in C, including dynamic
memory allocation, working with arrays, and passing variables to functions by
reference. However, working with pointers requires a good understanding of
memory management and can be error-prone if not done carefully.

\subsection{Dereference:}
\label{sec:orgba50c1d}
Note that the * sign can be confusing here, as it does two different things in our code:

When used in declaration (int* ptr), it creates a pointer variable.
When not used in declaration, it act as a dereference operator.
Good To Know: There are two ways to declare pointer variables in C:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
int* myNum;
int *myNum;
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Pointers are one of the things that make C stand out from other programming
languages, like Python and Java.

They are important in C, because they allow us to manipulate the data in the
computer's memory. This can reduce the code and improve the performance. If you
are familiar with data structures like lists, trees and graphs, you should know
that pointers are especially useful for implementing those. And sometimes you
even have to use pointers, for example when working with files.

But be careful; pointers must be handled with care, since it is possible to
damage data stored in other memory addresses.

\section{Pointers and Arrays:}
\label{sec:orge476bee}
You can also use pointers to access arrays.
Consider the following array of integers:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
int myNumbers[4] = {25, 50, 75, 100};
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Loop through the array elements with a for loop:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNumbers[4] = {25, 50, 75, 100};
  int i;

  for (i = 0; i < 4; i++) {
    printf("%d\n", myNumbers[i]);
  }
}
\end{verbatim}
Output:
\begin{verbatim}
25
50
75
100
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Now instead of printing the value of each array element, print the memory
address of each array element:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNumbers[4] = {25, 50 , 75, 100};
  int i;

for (i = 0; i < 4; i++) {
  printf("%p\n", &myNumbers[i]);
}
}
\end{verbatim}
Output:
\begin{verbatim}
0x7ffc285a9830
0x7ffc285a9834
0x7ffc285a9838
0x7ffc285a983c
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Note that the last number of each elements' memory is address is different, with
an addition of 4.
This is due to the size of an 'int' type being typically 4 bytes.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myInt;

printf("%lu", sizeof(myInt));

}
\end{verbatim}
Output:
\begin{verbatim}
4
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
From the memory address example above you can see that the compiler reserves 4
bytes of memory for each array, element, which means that the entire array takes
up 16 bytes (4*4) of memory storage:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNumbers[4] = {25, 50, 75, 100};

  printf("%lu", sizeof(myNumbers));
}
\end{verbatim}
Output:
\begin{verbatim}
16
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
\subsection{How are pointers related to arrays:}
\label{sec:orgc4b0050}
The name of an array is actually a pointer to the first element of the array.
See in the example below that the memory address of the first element is the
same as the name of the array:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNumbers[4] = {25, 50, 75, 100};

  printf("%p\n", myNumbers);
  printf("%p\n", &myNumbers[0]);
}
\end{verbatim}
Output:
\begin{verbatim}
0x7ffcd8fd0b30
0x7ffcd8fd0b30
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
This shows that it is possible to work with arrays through pointers.
Since myNumbers is a pointer to the first element in myNumbers you can use the *
operator to access it.

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNumbers[4] = {25, 50, 75, 100};

  //Get the value of the fist element in myNumbers
  printf("%d\n", *myNumbers);

  //Get the value of the second element in myNumbers
  printf("%d\n", *(myNumbers + 1));

  //Get the value of the third element in myNumbers
  printf("%d\n", *(myNumbers + 2));

  //Get the value of the fourth element in myNumbers
  printf("%d\n", *(myNumbers + 3));
}
\end{verbatim}
Output:
\begin{verbatim}
25
50
75
100
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
Or loop through the array:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNumbers[4] = {25, 50, 75, 100};
  int *ptr = myNumbers;
  int i;

  for (i = 0; i < 4; i++) {
    printf("%d\n", *(ptr + i));
    }
}
\end{verbatim}
Output:
\begin{verbatim}
25
50
75
100
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
It is also possible to change the value of array elements with pointers:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int main(){
  int myNumbers[4] = {25, 50, 75, 100};
  //Change the value of the first element to 13
  *myNumbers = 13;

  //Change the value of the second element to 17
  *(myNumbers + 1) = 17;

  //Print value of the first element
  printf("%d\n", *myNumbers);

  //Get the value of the second element
  printf("%d\n", *(myNumbers + 1));
}
\end{verbatim}
Output:
\begin{verbatim}
13
17
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
This way of working with arrays might seem a bit excessive. Especially with
simple arrays like in the examples above. However, for large arrays, it can be
much more efficient to access and manipulate arrays with pointers.

It is also considered faster and easier to access two-dimensional arrays with
pointers.

And since strings are actually arrays, you can also use pointers to access
strings.

\section{Functions:}
\label{sec:orgcf10486}
A function is a block of code which only runs when it is called.
You can pass data known as parameters into a function. Functions are used to
perform certain actions, and they are important for reusing code: Define the
code once and use it many times.
Functions are essentially used to break down a large program into smaller,
manageable parts.
Functions in C have the following characteristics:
\begin{enumerate}
\item A function is defined using the "function" keywrod followed by the return
type, function name, and parameters (if any) in parentheses.
\item The code insude the function is enclosed in curly braces \{\}.
\item A function can have zero or more parameters, which are used to pass data to
the function.
\item A function can have a return type, which indicates the type of data the
function will return when it completes its task.
\item When a function is called, control  is transferred to the function, and the
code inside the function is executed. After the function completes it's task,
control is returned to the calling function.
\item Functions can be called from other functions, or from the main program.

Below is an example of a simple function in C:

\noindent\rule{\textwidth}{0.5pt}
\begin{verbatim}
#include <stdio.h>

int square(int num) {
  int result;
  result = num * num;
  return result;
  }

int main(){
  int num = 5;
  int sqr;
  sqr = square(num);
  printf("The square of %d is %d\n", num, sqr);
  return 0;
}
\end{verbatim}
\end{enumerate}
Output:
\begin{verbatim}
The square of 5 is 25
\end{verbatim}

\noindent\rule{\textwidth}{0.5pt}
In this example, the "square" function takes an integer parameter "num",
calculates the square of "num", and returns the result. The "main" function
calls the "square" function, passing it the value 5. The returned result is then
assigned to the "sqr" variable, which is then printed to the console using the
printf function.

Functions are an essential part of C programming, allowing you to break down
complex programs into smaller, more manageable parts.






























\clearpage
\section{Footnotes:}
\label{sec:org4d521f3}
\end{document}